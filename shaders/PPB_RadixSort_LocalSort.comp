#version 450

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
//---------------------------------------------------------
// Structs
//---------------------------------------------------------

struct PhotonBeam
{
	vec3 startPos;
    uint mortonCode;
    vec3 endPos;
    float radius;
    uint dataIdx;
    uint _padding_beam[3];
};

struct SortElement
{
    uint idx;
    uint mortonCode;
};

//---------------------------------------------------------
// Descriptor Set
//---------------------------------------------------------
layout (binding = 0, std430) restrict buffer PhotonBeams
{
    uint beamCount;
    uint _padding_beams[3];
    PhotonBeam photonBeams[];
};

layout (binding = 1, std430) restrict buffer Histogram4b
{
    uint histogram[];
};

layout(push_constant) uniform PushConstants
{
    uint baseShift;
    uint currentBuffer;
    uint workGroupCount;
};

//---------------------------------------------------------
// Consts
//---------------------------------------------------------
const uint MAX_UINT = 4294967295;
const uint ELEMENTS_PER_THREAD = 4;
const uint ELEMENTS_PER_WORK_GROUP = ELEMENTS_PER_THREAD * gl_WorkGroupSize.x;

//---------------------------------------------------------
// Helper Variables
//---------------------------------------------------------
shared SortElement localSort[ELEMENTS_PER_WORK_GROUP * 2];
shared uint scatterOffsets[ELEMENTS_PER_WORK_GROUP];
shared uint falses[ELEMENTS_PER_WORK_GROUP];
shared uint localHistogram[16];

uint workGroupOffset = gl_WorkGroupID.x * ELEMENTS_PER_WORK_GROUP;
uint localStartIdx = gl_LocalInvocationID.x * ELEMENTS_PER_THREAD;
uint localEndIdx = localStartIdx + ELEMENTS_PER_THREAD;

//---------------------------------------------------------
// Helper Functions
//---------------------------------------------------------
void calculateScatterOffsets(const uint readOffset, const uint nthShift)
{
    uint elementCount = int(min(ELEMENTS_PER_WORK_GROUP, beamCount - gl_WorkGroupID.x * ELEMENTS_PER_WORK_GROUP));
    uint offset[ELEMENTS_PER_THREAD] = {1, 1, 1, 1};

    // Mark 1 and 0
    for(uint i = localStartIdx; i < localEndIdx; i++)
    {
        falses[i] = (localSort[readOffset + i].mortonCode >> nthShift) ^ 1;
        scatterOffsets[i] = falses[i]; // reusing final buffer to save memory
    }
    barrier();
 	
    // Scan the 1s - Build sum in place up the tree
    uint currentIdx;
    for (uint d = elementCount >> 1; d > 0; d >>= 1)
    {
        barrier();
        currentIdx = 0;
        for(uint i = localStartIdx; i < localEndIdx; i++)
        {
            if (i < d)
            { 
                uint ai = offset[currentIdx] * (2 * i + 1) - 1;
                uint bi = offset[currentIdx] * (2 * i + 2) - 1;

                falses[bi] = falses[bi] + falses[ai];
            }
            offset[currentIdx] *= 2;
            currentIdx++;
        }
    }

    // Clear the last element 
    uint totalFalses = falses[elementCount - 1];
    if (gl_LocalInvocationID.x == 0)
    { 
        falses[elementCount - 1] = 0;
    }
    
    // Traverse down tree & build scan
    for (int d = 1; d < elementCount; d *= 2)
    {      
        barrier();
        currentIdx = 0;
        for(uint i = localStartIdx; i < localEndIdx; i++)
        { 
            offset[currentIdx] >>= 1;
            if (i < d)
            { 
                uint ai = offset[currentIdx] * (2 * i + 1) - 1;
                uint bi = offset[currentIdx] * (2 * i + 2) - 1;
                uint t = falses[ai];
                falses[ai] = falses[bi];
                falses[bi] += t;
            }
            currentIdx++;
        } 
    }

    // Wait for all threads to finish
    barrier();

    // Calculate scatter indexes
    for(uint i = localStartIdx; i < localEndIdx; i++)
    {
        scatterOffsets[i] = (scatterOffsets[i] == 0) ? (i - falses[i] + totalFalses) : falses[i];
    }
} 

//---------------------------------------------------------
// Main
//---------------------------------------------------------
void main() 
{    
    // Calculate current pass beam buffer offset
    uint writeBeamOffset;
    uint readBeamOffset;
    if(currentBuffer == 0)
    {
        readBeamOffset = 0;
        writeBeamOffset = beamCount;
    }
    else
    {
        readBeamOffset = beamCount;
        writeBeamOffset = 0;
    }

    // Check if in bounds
    if(workGroupOffset + localStartIdx >= beamCount)
    {
        localStartIdx = MAX_UINT;
    }
    if(workGroupOffset + localEndIdx > beamCount)
    {
        localEndIdx = beamCount;
    }

    // Copy elements to shared memory
    for(uint i = localStartIdx; i < localEndIdx; i++)
    {
        localSort[i].idx = workGroupOffset + i;
        localSort[i].mortonCode = photonBeams[readBeamOffset + localSort[i].idx].mortonCode;
    }

    // Radix sorting loop - 4x 1-bit Radix, as specified by "Designing Efficient Sorting Algorithms for Manycore GPUs"
    bool writeToFirstBuffer = false;
    uint writeOffset = ELEMENTS_PER_WORK_GROUP;
    uint readOffset = 0;
    uint iteration = 0;
    uint nthShift = 0;
    while(iteration < 1)
    {
        // n-th bit to be compared
        nthShift = baseShift + iteration;

        // Calculate offsets
        calculateScatterOffsets(readOffset, nthShift);

        // Move elements to their respective position
        for(uint i = localStartIdx; i < localEndIdx; i++)
        {
            localSort[writeOffset + scatterOffsets[i]] = localSort[readOffset + i];
        }

        // Wait until all threads have cleared their ranges in the elements counting
        barrier();

        // Update parameters
        iteration++;
        writeToFirstBuffer = !writeToFirstBuffer;
        readOffset = writeToFirstBuffer ? ELEMENTS_PER_WORK_GROUP : 0;
        writeOffset = writeToFirstBuffer ? 0 : ELEMENTS_PER_WORK_GROUP;
    }

    // Count 4-bit local histogram
    uint maskedIdx = 0;
    for(uint i = localStartIdx; i < localEndIdx; i++)
    {
        maskedIdx = (localSort[readOffset + i].mortonCode >> baseShift) & 15;
        atomicAdd(localHistogram[maskedIdx], 1);
    }
    barrier();

    // Copy local histogram to global table in global memory - column major as instructed by paper
    if(gl_LocalInvocationID.x < 16)
    {
        histogram[gl_LocalInvocationID.x * gl_NumWorkGroups.x] =  localHistogram[gl_LocalInvocationID.x];
    }
    
    // Copy elements back to global memory
    for(uint i = localStartIdx; i < localEndIdx; i++)
    {
        photonBeams[writeBeamOffset + workGroupOffset + i] = photonBeams[readBeamOffset + localSort[readOffset + i].idx];
        photonBeams[writeBeamOffset + workGroupOffset + i]._padding_beam[0] = gl_GlobalInvocationID.x;
        photonBeams[writeBeamOffset + workGroupOffset + i]._padding_beam[1] = i;
    }
}