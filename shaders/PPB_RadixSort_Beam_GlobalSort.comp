#version 450

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
//---------------------------------------------------------
// Structs
//---------------------------------------------------------

struct PhotonBeam
{
    uint mortonCode;
	vec3 startPos;
    float radius;
    vec3 endPos;
	vec4 power;
};

//---------------------------------------------------------
// Consts
//---------------------------------------------------------
const uint ELEMENTS_PER_THREAD = 4;
const uint ELEMENTS_PER_WORK_GROUP = ELEMENTS_PER_THREAD * gl_WorkGroupSize.x;

//---------------------------------------------------------
// Descriptor Set
//---------------------------------------------------------
layout (binding = 0, std430) restrict buffer SortedPhotonBeams
{
    uvec4 sortedbeamCount;
    PhotonBeam sortedPhotonBeams[];
};

layout (binding = 1, std430) restrict buffer GlobalSortedPhotonBeams
{
    uvec4 globalSortedBeamCount;
    PhotonBeam globalSortedPhotonBeams[];
};

layout (binding = 2, std430) restrict buffer Histogram16b
{
    uint histogram[];
};

layout (binding = 3, std430) restrict buffer ScannedHistogram16b
{
    uint scannedHistogram[];
};

layout(push_constant) uniform PushConstants
{
    uint baseShift;
};

//---------------------------------------------------------
// Main
//---------------------------------------------------------
void main() 
{
    if(gl_GlobalInvocationID.x == 0)
    {
        globalSortedBeamCount = sortedbeamCount;
    }

    uint workGroupOffset = gl_WorkGroupID.x * ELEMENTS_PER_WORK_GROUP;
    uint startIdx = gl_LocalInvocationID.x * ELEMENTS_PER_THREAD;

    // Pre-calculate offsets
    uint offsets[ELEMENTS_PER_THREAD];
    uint mask = 15 << baseShift;
    uint maskedIdx = 0;
    uint bucketStartIdx = 0;
    for(uint i = 0; i < ELEMENTS_PER_THREAD; i++)
    {
        maskedIdx = sortedPhotonBeams[workGroupOffset + startIdx + i].mortonCode & mask;
        maskedIdx = maskedIdx >> baseShift;
        offsets[i] = scannedHistogram[maskedIdx * gl_WorkGroupSize.x + gl_WorkGroupID.x];

        // Get offset from the start of the sequence with in the same key
        for(uint i = 0; i < maskedIdx; i++)
        {
            bucketStartIdx += histogram[gl_WorkGroupSize.x * i + gl_WorkGroupID.x];
        }
        offsets[i] += startIdx - bucketStartIdx;
    }

    // Copy locally sorted beams to their global positions
    for(uint i = 0; i < ELEMENTS_PER_THREAD; i++)
    {
        globalSortedPhotonBeams[offsets[i]] = sortedPhotonBeams[workGroupOffset + i];
    }
}